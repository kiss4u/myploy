# Redis

[TOC]

## 数据类型

| 类型                 | 简介                                                   | 特性                                                         | 场景                          | 实现原理                            |
| :------------------- | :----------------------------------------------------- | :----------------------------------------------------------- | :---------------------------- | ----------------------------------- |
| String(字符串)       | 二进制安全                                             | 可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M | ---                           |                                     |
| Hash(字典)           | 键值对集合                                             | 适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去) | 存储、读取、修改用户属性      |                                     |
| List(列表)           | 链表(双向链表)                                         | 增删快,提供了操作某一段元素的API                             | 1、消息队列 2、数据分页       | quicklist （zipList组成的双向链表） |
| Set(集合)            | 哈希表实现,元素不重复                                  | 增删查复杂度O(1) ，提供了交集、并集、差集等操作              | 1、共同好友、喜好等 2、访问量 |                                     |
| Sorted Set(有序集合) | 将Set中的元素增加一个权重参数score,元素按score有序排列 | 集合内元素有序                                               | 1、排行榜 2、延迟消息队列     | skipList                            |

## 底层结构

### SDS（Simple Dynamic String）

>redis底层用C语言实现，它没有用C语言的字符类型，自己实现了一套SDS结构

```c
struct sdshdr {
    // 当前字符串长度
	int len;
    // 剩余可用长度
	int free;
    // 实际存储字符串
	char buf[];
}
```

> reids的key是一个SDS值，value如果是String类型，实际存储的也是SDS，非String是long类型

### 与C字符串的区别

#### 1、计数方式

>C字符串从前向后遍历，知道空字符（\0）为止
>
>sds自己维护了len长度

#### 2、长度变更

>C字符串做修改比如拼接，如果没计算好内存，会产生溢出
>
>sds通过free判断剩余空间是否足够，如果不够会进行扩容

#### 3、减少修改时内存重新分配次数

> 每次修改后，预留free空间，避免频繁扩展；（如果多次未用到会回收）

#### 4、二进制安全

> C通过空字符（\0）判断长度，很多数据类型会穿插空字符比如说图片视频音频等，sds使用len避免了这种误判

## 单线程模型

>IO多路复用，命令都放入队列，文件事件处理器单线程执行消费
>
>1、纯内存操作
>
>2、多路复用
>
>3、单线程避免上下文切换

## 过期策略

> 1. 定时删除：设置每隔n秒执行一次，随机抽取设置了过期时间的key，检查是否过期删除	
>
> 2. 惰性删除：获取key时，检查是否存在过期时间，如过期则删除

## 淘汰机制

> 定时删除和惰性删除都没触碰，达到最大存储空间，有新key加入
>
> 2. allkeys-lru：全量key中，移除最少使用的
> 3. allkeys-random：全量key中，随机抽取移除
> 4. volatile-lru：在设置了过期时间的key中，移除最少使用的
> 5. volatile-random：在设置了过期时间的key中，随机抽取移除
> 6. volatile-ttl：在设置了过期时间的key中，移除剩余时间最短的
> 7. noeviction：不删除，直接返回错误

## 手写LRU？

> LinkedHashMap，按访问时间排序

## ReHash

当hash表保存的数据过多或过少时，对哈希表的大小进行相应的扩展或者收缩

>1、为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表
>
>2、维持索引计数器变量rehashidx，并将它的值设置为0，表示rehash开始
>
>3、每次对字典执行增删改查时，将ht[0]的rehashidx索引上的所有键值对rehash到ht[1]，将rehashidx值+1
>
>4、当ht[0]的所有键值对都被rehash到ht[1]中，程序将rehashidx的值设置为-1，表示rehash操作完成

## 持久化

### RDB

> 快照
>
> 同步回写：save
>
> 异步回写：bgsave，新建一个子进程执行

### AOF

>增量日志

## 扩容

### Pre-Sharding

>Pre-Sharding方法是将每一个台物理机上，运行多个不同断口的Redis实例。
>
>假如有三个物理机，每个物理机运行三个Redis实例，那么我们的分片列表中实际有9个Redis实例，当我们需要扩容时，增加一台物理机，步骤如下：
>
>A.   在新的物理机上运行Redis-Server；
>
>B.   该Redis-Server从属于(slaveof)分片列表中的某一Redis-Server（假设叫RedisA）；
>
>C.   等主从复制(Replication)完成后，将客户端分片列表中RedisA的IP和端口改为新物理机上Redis-Server的IP和端口；
>
>D.   停止RedisA。
>
>这样相当于将某一Redis-Server转移到了一台新机器上。Prd-Sharding实际上是一种在线扩容的办法，但还是很依赖Redis本身的复制功能的，如果主库快照数据文件过大，这个复制的过程也会很久，同时会给主库带来压力。所以做这个拆分的过程最好选择为业务访问低峰时段进行。

## 主从同步方式

>1、正常是每条命令都发给slave进行同步
>
>2、slave首次连接，master向slave发送全量数据，后续增量发送rdb文件，支持断点续传
>
>3、无磁盘化，配置参数开启，master的RDB不先落盘，直接从内存中发送给slave
>
>4、msater执行key过期，发送del命令给slave

slave定时检查是否跟master连接，如果master配置了认证，发送口令过去校验，开始执行全量复制，后续进行增量复制

master和slave都维护一个offset，对比来进行增量、断点

## 高可用

> 哨兵模式，主备切换

## 异步复制、脑裂问题导致的数据不一致

> min-replicas-to-write 3	最少的salve节点为3个，第二个参数表示
>
> min-replicas-max-lag 10	数据复制和同步的延迟不能超过10秒
>
> 如果发现数据复制延迟或脑裂，原master会在客户端写入操作的时候拒绝请求，避免大量数据丢失。

## 哨兵

> 主观宕机：自己认为挂了
>
> 客观宕机：quorum数量的哨兵都认为挂了

自动发现机制

> 哨兵定时向master/slave的channel发送一条消息，其他哨兵订阅

选举算法

> 1、跟master断开的时长，越长越不适合
>
> 2、slave优先级，配置的
>
> 3、offset位置，同步内容的多少
>
> 4、run id

切换

> 主从切换，哨兵会生成一个version，其他哨兵通过这个version来判断本地的配置是否最新



## cluster

> 实现分布式存储
>
> 
>
> slot取值范围0-16383，每个节点都分布slo，会用key通过crc16算法得出一个值，访问对应节点





