# 缓存

[TOC]

## 为什么要用缓存

> 提高响应效率
>
> 降低数据库压力

## 缓存可能会有什么不良后果

> 数据不一致
>
> 并发竞争
>
> 缓存雪崩
>
> 缓存穿透

## Redis与Memcache对比

> Redis支持数据类型丰富
>
> Redis可以持久化
>
> Redis支持事务
>
> memcache原生不支持集群模式

## 缓存穿透

> 1、缓存不存在

#### 解决方案

> 数据预热

## 缓存雪崩

> 1、集群挂掉
>
> 2、大量key同时过期

### 解决方案

>1、前：搭建高可用集群，主从架构，双机房部署
>
>2、中：本地缓存、访问缓存的线程资源隔离、熔断降级、对源数据的访问限流
>
>3、后：数据备份恢复、缓存预热

## 缓存击穿

> 1、大量查请求时缓存失效

### 解决方案

> 定时更新

## 缓存数据一致性

cache aside pattern

> 1、读取时，有缓存读缓存，无缓存读库加缓存
>
> 2、更新时：
>
> （1）先删缓存再改数据库，可能会出现数据不一致（读写并发）；
>
> （2）先改数据库再删缓存，可能会出现数据不一致（读写并发时，缓存刚好失效，读取出了旧数据，且在并发写操作之后把旧数据更新到了缓存，或者网络异常导致缓存删除失败）
>
> 一般采用第二种，出现数据不一致的概率更小，需要在读写同时发生，且缓存恰好失效，读操作比写操作耗时更长情况下才会出

#### 优化方案

##### 缓存延时双删

> 1、先删除缓存
>
> 2、再写数据库
>
> 3、休眠n毫秒再删除一次缓存（评估读操作的耗时，mysql主从同步的耗时（读写分离））

##### 删除失败重试机制

> 1、利用canal中间件，订阅binlog日志入队列，异步淘汰cache
>
> 2、提供多个内存队列，根据唯一标识进行hash路由后进队列，每个队列一个线程消费，读写串行化执行，保证生成缓存数据一致；

> 读操作会排重后进队列，业务线程阻塞n毫秒循环去查缓存，超时未查到就直接查库；
>
> 要注意请求路由到同一台机器，可能会出现热点问题

### 为什么数据库变动后，删除缓存而不是更新缓存？

> 1、缓存数据可能是多个表数据关联计算出的结果
>
> 2、冷数据缓存，频繁更新却不一定会被调用，没必要每次都及时更新，读时懒加载

## 电商系统页面三级缓存

时效性要求低的采用异步缓存，要求高的采用实时缓存

> 1、nginx缓存静态模板 + lua查询redis构建页面，缓存少量热数据
>
> 2、redis，缓存大量离散请求数据
>
> 3、堆缓存
>
> 先找nginx上的数据缓存，如果没有取查redis，如果redis没有通过服务查数据库，然后生成redis缓存（如果redis有生成nigix缓存）