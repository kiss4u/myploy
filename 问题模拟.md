# 问题模拟

[TOC]

## Java

### 基础

#### aaa？

>

### 并发多线程

#### 线程通信方式

>1、wait()、notify()、notifyAll()
>
>2、condition中的await()、singnal()、signalAll()

sleep和yield

#### 共享变量通过什么方式保证多线程安全？

> 1、修改的时候加锁
>
> 2、volatile + cas
>
> 3、ThreadLocal存储

##### `扩展`ThreadLocal是如何实现的？内部存储方式，key是什么？value是什么？如何查找的？内存泄漏？

>Thread中有变量threadLocals，threadLocals指向创建的ThreadLocal
>
>内部ThreadLocalMap类型，key是ThreadLocal对象，value是一个数组

##### `扩展`ThreadLocal内存泄漏？

>ThreadLocal用完需要remove，否则容易造成内存泄漏。
>
>弱引用，多个ThreadLocal变量，一个不用了，但是Thread中map里存的value还在存

##### `扩展`子线程能够访问父线程的变量吗？通过什么方式？

>1、可以在创建子线程的时候传入
>
>2、创建InheritThreadLocal（是ThreadLocal的子类，复写了createMap和getMap方法，实现原理相同）
>
>子线程创建的时候，会检查当前线程中inheritThreadLocal变量是否有值，有则复制一份给子线程。

#### Random多线程下会有什么问题？如何避免？

>Random需要靠随机种子来计算随机数，多线程可能会获取到同一个随机种子出现重复，为了避免这种情况Random里使用了AutomicLong + cas，当大量并发的时候做cas时，会影响系统性能。
>
>ThreadLocalRandom，随机种子存放在调用线程内，每个线程用自己的参数计算

#### ABA问题如何解决？

>加版本号

#### Unsafe类

>提供native方法，JNI调用c++代码实现硬件级别的原子操作
>
>位于rt.jar包下，bootstrap类加载器负责加载
>
>main函数下使用AppClassLoader加载，无法直接获取到Unsafe对象，需要使用反射

#### AutomicLong，LongAdder和LongAccumulator

> volatile 保证取到的都是当前最新的值，不从线程内存缓存中取值，每次都从主存中获取，
>
> AutomicLong原子类，使用unsafe类下方法，volatile + cas
>
> LongAdder，volatile，basic值 + 多个cell元素（数组存储），get大小的时候求和，只保证大小最终一致性，并发量少的时候直接修改basic值，并发大的时候线程cas竞争某个cell对象操作
>
> LongAccumulator可以理解为LongAdder的扩展，LongAdder只支持加法，LongAccumulator可以定义其他公式（函数式接口实现）

#####  `扩展`为什么分段用cell对象不直接用基本数据类型？

>避免缓存伪共享

#### 什么是缓存伪共享？如何避免？

>多个变量放在同一个缓存行中，当其中一个发生变化，整个行都失效，其他变量来获取的时候，也都需要重新从主存中获取
>
>一个缓存行只存一个变量，通过把富裕的空间占满实现
>
>可以使用注解x.x.content（需要在jvm配置开启）

#### AQS(abstract queued synchronizer)

>AQS是一个抽象类，锁实现要用到这个抽象类；
>
>AQS的内部维护一个阻塞队列，调用lock()获取锁失败的线程，都被转化成node节点进到该队里中，开始自旋cas尝试获取锁
>
>线程获取到了锁，锁创建了一个条件变量condition，当调用wait时，将线程放到对应的condition队列中
>
>接收到signal/signall信号后，转移到AQS阻塞队列中cas

#### LockSupport作用

>锁实现用到的工具类，用来中止(pack)和恢复(unpack)线程，

#### 什么是乐观锁和悲观锁？公平锁和非公平锁？独占锁和共享锁？可重入锁？自旋锁？

>- 乐观锁：获取时不加锁，只在修改的时候加锁
>- 悲观锁：获取的时候就加锁
>- 公平锁：当资源被释放后，其他锁的请求按先后顺序获取，举例ReentrantLock()
>- 非公平锁：当资源被释放后，先尝试获取一次，如获取失败，则进入公平锁的方法，ReentrantLock(true)
>- 独占锁：同一时间只允许一个线程获取，ReentrantLock
>- 共享锁：可以允许多个线程获取到
>- 可重入锁：获取到锁以后可以重复再获取，存在一个计数
>- 自旋锁：不断尝试获取锁，cas，JVM参数可以配置循环次数

#### 线程池的作用（使用队列类型）

> 线程重用，减少线程的频繁创建和销毁，减少资源消耗；
>
> 提高响应速度，不需要等待线程创建；
>
> 提供线程的可控性
>
> 
>
> ConcurrentLinkedQueue 非阻塞，单向链表 + cas
>
> LinkedBlockingQueue 无界阻塞队列 	单量链表 + ReentrantLock
>
> ArrayBlockingQueue 有界阻塞队列 
>
> PriorityBlockingQueue 带优先级的无界队列，数组queue + compareTo实现
>
> DelayQueue 无界延迟队列 PriorityQueue存放，元素带一个过期时间

#### 使用线程池提交任务，此时线程池队列满了会发生什么？

>

#### 为什么使用ThreadPoolExcutor不是用Excutor创建线程池？

>Excutor创建线程池使用默认参数，可能发生OOM

#### 主线程如何等待子线程都执行完毕汇总？同步器的几种类型

>同步计数器
>
>回环屏障
>
>信号量

#### 线程安全的List、map

>concurrentHashMap

#### 高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？线程数设置多少比较合适？

>高并发、时间短：属于CPU密集型，LinkedBlockingQueue，核心线程数为cpu核数n+1，最大线程数2n？
>
>低并发、时间长：IO密集型，线程数设置2n
>
>高并发、时间长：IO密集型，线程数设置得多一点，n/(1-阻力系数(0.8或0.9))

#### BIO、NIO、AIO、多路复用IO含义

>IO模型：
>
>​		BIO阻塞IO，IO请求等待处理
>
>​		NIO 非阻塞IO，有空闲处理，没空闲返回失败，下次尝试
>
>​		AIO 异步IO，接受请求，处理完成发送通知
>
>​		多路复用IO，接受请求注册到selector，轮询处理

#### 多路复用是如何设计实现的？

>reactor模式实现多路复用
>
>一个mianReactor只负则处理连接请求，处理完成后把socketChannel传递给subReactor，以后请求都subReactor处理（此处是指网络IO请求），具体业务逻辑交由线程池处理

#### 什么是事务？事务的特征

>事务是一组行为，具有原子性A、一致性I、隔离性D、永久性C几个特征
>
>原子性：要么都执行，要么都不执行
>
>一致性：从一个状态变更到另一个状态
>
>隔离性：多个事务执行期间之间无法相互影响
>
>永久性：数据会被永久改变

#### 如何实现乐观锁？

>加版本号或时间戳，修改的时候对比

#### 如果避免死锁？

>首先看死锁是如何产生的?
>
>死锁产生需要满足几个条件：
>
>- 多个线程对资源产生竞态条件
>- 在获取其他资源时，对已持有的资源保持占有不释放
>- 不可强行抢夺已被其他线程持有的资源
>- 资源首尾循环获取
>
>对资源进行排序，保证获取的先后顺序，避免出现循环获取
>
>死锁与活锁的区别？
>
>都是无法向下执行，区别在于死锁的状态一直不变，活锁的状态是在变化，可能通过资源顺序解开

## JVM

#### 内存区域的划分？有什么特点？

>堆：对象
>
>方法区：静态常量
>
>jvm栈：指针
>
>本地栈：native方法
>
>计数器：

#### 堆中分为哪几代？分代回收是指什么？

>新生代：分edon和suvivor区，满了执行yongGC，会将edon区中存活对象转移到suvivor1区，下一次再将edion和suvivor1中存活的迁移到suvivor2，（如果满了直接进老年代），迁移几次之后会进入老年代（次数JVM可配）
>
>老年代：满了执行fullGC，全量GC

#### 会对哪些对象进行回收？

> 1、没有直接指向对象的引用
>
> 2、
>
> 3、

#### GC收集器有哪些，收集算法有哪些？

>串行回收器：只有一个线程执行GC
>
>并行回收器：多个线程执行GC
>
>并发回收器：正常执行FullGC会停止系统服务，GC和系统服务一起运行
>
>G1回收器：

#### 类加载过程？什么是双亲委派模型？

>加载过程？
>
>双亲委派模型：类加载时，先调用父类加载器，父类加载器无法加载再交由子类加载，为了保证生成对象一致

#### JVM优化java代码时做了什么？（TLAB）

>

#### JVM调优工具？

>jstack 查看线程，栈调用是否有死锁
>
>jmap 查看堆空间
>
>dump文件
>
>飞行日志

#### 服务器CPU过高如何排查？

> top                                                #定位异常的进程
> top -H -p pid                                      #查看异常的线程
> strace -T -r -c -p pid                             #查看系统调用和花费的时间
> printf "%x/n"线程号                                 #将异常线程转化为16进制
> jstack 进程号|grep 线程号（16进制异常线程号）-A90     #定位异常的代码

## 数据库

#### 什么是事务CAID

>

#### 事务的级别

>

#### mysql使用悲观锁(for update)可能出现什么问题？

>查询条件没有索引，或者有索引但是未命中索引，无法用行级锁导致使用表级锁

#### 如何解决死锁？避免死锁？

>

#### 什么情况下需要建索引

> 1、数据量大
>
> 2、where条件中经常出现的列

#### 什么情况下不需要建索引

>1、列中的数据值比较单一
>
>2、

#### varchar和char的区别

> 1、char定长，插入小与指定长度，以空格填充，varchar变长，按照实际长度存储
>
> 2、varchar的最大存储容量比char大
>
> 如果知道存储的是固定长度（比如说密码），可以用char，存取效率更高

#### varchar(10)、int(4)、int(10)

>varchar(10)表示申请存储大小，不能超长
>
>int(4)、int(10)代表显示长度，如果设置了填充0，会补位，存储大小是相同的

#### BTree和B+Tree

> BTree：非页节点存数据键值，当data量大时，每一页能存储的key（非页节点少）就会变少，导致导致深度大，查询效率不稳定（mongoDB）
>
> B+Tree：数据都放在叶子节点，非叶子节点只存key，非页节点之间存在一个指针，查询效率稳定（InnoDB存储引擎）

#### MySQL索引为什么要用 B+ Tree而不用红黑树呢？

>AVL和红黑树一般用于内存存储才会使用
>
>B+ Tree适合做大数据量索引结构，整棵树存储在硬盘，读写时将某个节点加载到内存
>
>红黑树的子节点只能有两个，B+Tree可以有多个节点，那么同样大小的数据红黑树深度更深，效率更低

#### MongoDB为什么要用 B Tree而MySQL用B+Tree存储呢？

> mysql关系型数据库，遍历操作比较多，B+Tree的结构所有 data 都存储在同一层叶节点，数据有序，方便遍历，查询效率稳定
>
> B树查询时间复杂度不固定，与 key 在树中的深度有关，最好为O(1)，有可能一次就命中，更适合mongo这种非关系型数据库

#### mysql如何实现大数据量的报表即时展示（即时增量同步数据）

>即时同步到其他地方比如说hive来做分析查询，即时同步可以通过读binlog
>
>比如阿里的canel项目，基于数据库增量日志（binlog）解析，提供增量数据订阅&消费

#### 如何不停机迁移数据？

> 1、数据双写
>
> 2、程序迁移旧数据，对比updateTime，保证数据最新

#### mysql执行查询的过程

> 解析器解析SQL语句
>
> 优化器优化查询路径
>
> 执行器调用引擎接口执行查询计划

#### 死锁怎么排查

> 查下死锁日志，找到sql对应代码

## 框架

#### 说一下netty/mina

>

#### netty是如何实现多路复用的？

>

#### spring、spring boot、spring cloud

> spring framwork
>
> spring boot：快速搭建服务的框架
>
> spring cloud：一个提供了多种服务的全家桶



## 消息中间件MQ

#### 作用

> 解耦、异步、削峰

#### 如何保证消息顺序

>1、都路由到同一个woker处理
>
>2、

## 缓存

### redis如何保证高并发高可用？

> 一主多从，读写分离
>
> 加入哨兵

#### 缓存雪崩

缓存服务失效了

> 增加二级缓存
>
> 限流、降级

#### 缓存穿透

缓存未查到，直接查DB，如果DB中也没有，增加压力

>1、布隆过滤器，把可能存在的数据hash存到bitmap中，不在bitmap里的一定不存在
>
>2、把不存在的值写到缓存中

#### 缓存击穿

大量集中访问一个key，当这个key失效时，直接访问DB

>1、定期更新，job定时检查过期时间是否小于n分钟，小于则更新缓存
>
>2、检查更新，每次get后，查询一下过期时间是否小于1min，小于则更新缓存
>
>3、当缓存查询结果为空时，加个ReentrantLock从DB写入缓存。（分布式下需要用redis、zookepper等分布式锁实现）

#### 缓存预热

>1、启动时提前读入
>
>2、定期读入

#### 缓存更新

>1、定期更新
>
>2、读时更新

#### 缓存降级

>限流
>
>熔断

## 分布式

### CAP

> Consistency：一致性，各节点数据发生变化时，读操作取到的都是最新
>
> Availability：可用性
>
> Partition tolerance：分区容错性，如果两个节点间不能通信，系统仍能正常提供服务

CAP原则：容错性P一定要保证，要么CP要么AP，CAP不可能同时实现。

#### 分布式数据划分

>1、Hash
>
>2、范围
>
>3、一致性hash
>
>通过某种Hash算法实现，计算出的值是一个封闭的圆，个个节点落在这个圆上，顺时针取最近的点，节点扩容和摘除都不影响流量
>
>计算出的节点Hash值在圆上分布不均匀，数据可能会便落在某些点上，通过增加虚拟节点（还是那些服务器），是的节点的分布均匀

#### 分布式节点为什么要奇数个？

>投票时防止出现平分

#### 一致性哈希

>就是用某种hash算法，计算出的值组成一个封闭的环，值都落在这个环的节点上，用户顺时针分配到最近的节点
>
>节点数少会发生偏移，增加多个虚拟节点

### 分布式事务解决方案

#### 二阶段提交

> 1、询问各个事务是否处理好
>
> 2、收到ack，执行提交或回滚

##### 缺点

>1、性能问题：所有参与者在事务提交阶段处于同步阻塞状态，占用系统资源，容易导致性能瓶颈。
>
>2、可靠性问题：如果协调者存在单点故障问题，或出现故障，提供者将一直处于锁定状态。
>
>3、数据一致性问题：在阶段 2 中，如果出现协调者和参与者都挂了的情况，有可能导致数据不一致。

#### 三阶段提交

>相比二阶段提交，同时在协调者和参与者中都引入超时机制，precommit保证提交阶段之前节点状态一致

![image-20200721113219824](%E9%97%AE%E9%A2%98%E6%A8%A1%E6%8B%9F.assets/image-20200721113219824.png)

#### 可靠消息

>

#### TCC

>

![img](https://img2018.cnblogs.com/blog/1746373/201907/1746373-20190720004716218-1490757197.png)

#### 最大努力通知

>

![img](https://img2018.cnblogs.com/blog/1746373/201907/1746373-20190720004740659-943326129.png)



### 分布式链路追踪

>每次服务调用都要经过一个框架，存储起来展示整个流程
>
>比如订单服务10:00，支付服务10:04:，库存服务10:10



## 网络

#### 序列化协议

>

#### TCP 粘包/拆包的原因及解决方法？此题不会

#### UDP和TCP的区别

>UDP不需要建立连接，消息传输不可靠，消息头小（8字节）
>
>TPC要建立连接，消息传输可靠，消息头大

#### TCP消息头长度是固定的的吗？

>不固定，【选项】的长度可变

#### 有一个IP的服务器，理论上TCP最大连接数是多少？

>最大端口数为2的16次方，ipv4最大ip为2的32次方，ipv6最大ip为2的128次方
>
>连接数 = 客户端ip数 * 客户端端口数

#### TCP三次握手和四次挥手

>三次握手：
>
>客户端向服务器发送连接请求SYN，服务器返回确认ACK，
>
>客户端接收，再返回ACK，确认已收到服务器的信息
>
>四次挥手：
>
>TCP是双向工作的，可互相发送数据；
>
>当客户端认为已方传输完成，发起断开请求FIN，服务器接收并返回确认ACK，此时客户端不再发送数据（状态为等待）
>
>等到服务器认为已放传输完成时，也发起断开请求FIN，客户端接收并返回ACK

#### TCP请求连接时，为什么是三次握手，不能用两次/四次握手？

>三次握手已经可以完成连接建立了，不需要更多通信次数。
>
>正常过程是客户端SYN、服务器ACK，服务器SYN，客户端ACK四步组成，
>
>未建立好连接前，不会发生信息传递，可以给中间的两步合并成一个步，变为三次握手。
>
>
>
>不用两次握手，主要为了
>
>1、防止出现失效请求重复连接初始化造成混乱，比如网络拥堵原因，客户端发了两次连接请求，
>
>服务器先收到了第一次旧的请求返回ACK，客户端根据序号发现这是旧的请求，可以发起RST告诉服务器第一次这个无效可以断开，用下一次的。
>
>2、同步双方的序列号，保证消息都被对方接收
>
>3、避免资源浪费

#### TCP第三次握手可以携带数据吗？

> 前两次不可以，第三次可以

#### TPC断开连接时，客户端关闭状态后为什么等待？（为什么需要TIME_WAIT状态？）

> 1、保证正常关闭
>
> 2、防止旧的数据包影响新连接
>
> TCP是一个双工，互相发送数据，如果客户端发送的最后一次ACK没有被服务器收到，服务器可以发起重传FIN，客户端可以做出响应，然后重置2MSL
>
> 为什么是2MSL？

#### 为什么是2MSL？

>MSL是报文最大生存时间，FIN、ACK的发送一来一回正好2MSL

#### TIME_WAIT过大有什么危害？

> 内存资源占用，消耗端口

#### 如果已经建立了连接，客户端故障了怎么办？

> 保活机制：指定时间n内无活动开启，每隔一段时间发送一个探测报文，多次无响应关闭连接，有响应重置n。（linux系统参数可以配置间隔时间、次数）

#### SYN攻击是什么？如何应对？

>服务器收到大量连接请求SYN，无法收到客户端的ACK，会占满SYN队列，无法正常提供客户服务
>
>解决方式：
>
>修改等待数
>
>修改服务器重发ACK次数

#### 零拷贝

> 数据避免内核态和用户态之间的copy切换，直接发送
>
> javaNIO、kafka、Netty等都用到了0拷贝

![img](https://pics1.baidu.com/feed/ca1349540923dd54e4b98972819036d89d824805.jpeg?token=654828cc7481f05ac9f0d3411d2a7430)

![img](https://pics3.baidu.com/feed/1f178a82b9014a90a5b8affdf9eebc14b21bee08.jpeg?token=7daa69535123fe792b17f0fc456af96f)

## 算法



## 其他

### 秒杀是如何保证高并发的

> 1、客户端限制点击频率
>
> 2、同个IP、用户ID的请求，限制n秒值透传一次，其他返回缓存页面
>
> 3、使用队列处理请求、增加有无状态的缓存
>
> 4、页面数据静态化，多级缓存（CDN + Nigix + redis）
>
> 设置一个最大数量，ConcurrentLinkedQueue存请求，LongAdder计数





### 限流常见方法

> 计数器：时间段内最多允许多少次请求，可能出现临界值问题
>
> 漏斗：请求加到队列里
>
> 令牌桶：设置一个令牌桶，以固定速率往里填充token，每当用户请求来时，从令牌桶中申请一个token，如果未成功获取，则抛弃用户请求。允许突发（通过一次性补充大量token到桶内）

### 为什么不直接用http而用RPC

>http是在接口不多、系统与系统交互较少的情况下
>
>大型的网站，内部子系统较多、接口非常多的情况下，使用RPC避免每次通信都要握手减少网络开销，而且有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统 一化的操作。第三个来说就是安全性

### 如果你们的系统允许用户上传文件，要怎么保证安全

>1、白名单校验
>
>2、限制文件大小
>
>3、限制文件类型（根据二进制数据开头的magic number字节来判断）

### redis的线程模型是什么？

> 文件事件处理器 单线程处理，使用 IO多路复用处理连接

### Snowflake算法发生时钟回拨该如何解决？

> 1、抛出异常，人工处理；百度uid-generator
>
> 2、延迟等待，将线程阻塞n毫秒，再次获取，如果还是小，继续等待；美团leaf
>
> 3、备用机，换另一台机器id
>
> 4、记录每次最大时间，记录上次时间周期内的最大id，以此向后生产
>
> 5、追赶时间，生成id不返回，直到大于回拨时











---

