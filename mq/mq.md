# 消息队列

[TOC]

## 为什么使用消息队列？

### 解耦

> 通过pub/sub方式实现服务调用解耦。（动态发布，推送审核）

### 异步处理

>实现非阻塞（动态发布，即时返回发布成功，客户端做自插入展示自己可见）

### 流量削峰

>保证系统平稳运行

## 引入要注意什么

> 1、系统的复杂性提高，是否要保证消息唯一、有序等待
>
> 2、可用性，MQ如果宕机会影响服务
>
> 3、一致性，数据是否全部订阅者都执行成功

## 常用的MQ

|            | ActiveMQ         | RabbitMQ                                                     | RocketMQ                | Kafka         |
| ---------- | ---------------- | ------------------------------------------------------------ | ----------------------- | ------------- |
| 吞吐量     | 万级             | 万级                                                         | 10万级                  |               |
| 消息可靠性 | 较低概率会丢消息 |                                                              | 参数配置0丢失           | 参数配置0丢失 |
| 优缺点     | 社区活跃度较低   | 开源社区活跃、erlang开发性能好、有管理界面、集群扩展比较复杂 | topic可以很多性能影响小 |               |
| 可用性     |                  |                                                              |                         |               |
| 适用场景   | 小规模图吞吐     |                                                              |                         | 大数据        |

## 如何保证高可用

### RabbitMQ

#### 普通集群模式

>主节点存放任务数据，访问子节点会从主节点获取数据

#### 镜像集群模式

>每个节点都放任务数据

### Kafka

> topic指定划分为n个partition，每个节点存一部分partition数据
>
> 单个节点分leader+follower主备两台机器，leader挂了，follower会被替换为leader继续提供读写

## 如何保证消息不被重复消费（幂等性）

### kafaka机制

> 通过zookeeper同步当前消费进度（offset）
>
> 但是还是可能出现重复比如说提交同步前宕机了



> 每条消息增加流水id，消费者做判重

## 如何保证消息传输可靠性

ack

生产者到mq

> 事务机制
>
> confirm机制，返ack回调成功/失败方法，失败重发

mq内部丢失

>持久化机制，持久化后返ack

mq到消费者

>消费成功返ack

## 如何保证消息传输时序性

> 1、消息进单独的有序队列被分发，分到同一个消费者被消费（如果多线程，则按id放进同一队列）
>
> 2、每条消息都采用ack机制

## 队列积压如何解决，磁盘如果快满了如何解决

>1、排查解决消费者故障
>
>2、开多个消费者消费
>
>3、消费不走正常逻辑，任务写到日志，低峰进行补单

## 如果你设计一个消息中间件，该考虑哪写内容

> 1、分布式参考kafka每个topic分多个partition放在不同节点，每个节点做主备保证高可用
>
> 2、可扩展，增加机器时重新划分数据
>
> 3、消息要落盘，实现宕机可恢复
>
> 4、ack机制，保证数据的入队出队