# 消息中间件

[TOC]

## 为什么使用消息队列

### 解耦

> 通过pub/sub方式实现服务调用解耦。（动态发布，推送审核）

### 异步处理

>实现非阻塞（动态发布，即时返回发布成功，客户端做自插入展示自己可见）

### 流量削峰

>保证系统平稳运行

## 使用时需要注意哪些

> 1、系统的复杂性提高，是否要保证消息唯一、有序等待
>
> 2、可用性，MQ如果宕机会影响服务
>
> 3、一致性，数据是否全部订阅者都执行成功

## 如何保证消息的可靠性（处理丢失问题）

> 生产者，开启事务，开启conform模式，返ack回调成功/失败方法，失败重发
>
> mq，数据持久化 durable
>
> 消费者，关闭自动ack，手动成功返ack

## 如何保证消息传输时序性

> 1、消息进单独的有序队列被分发，同批次任务分配到同一个消费者消费（如果多线程，则按id放进同一队列）
>
> 2、每条消息都采用ack机制

## 队列积压如何解决，磁盘如果快满了如何解决

>1、排查解决消费者故障
>
>2、开多个消费者消费
>
>3、消费不走正常逻辑，任务写到日志，低峰进行补单

## 消息中间件如何保证消息不被重复消费

> 1、通过zookeeper同步当前消费进度（offset）
>
> 但是还是可能出现重复比如说提交同步前宕机了
>
>2、每条消息增加流水id，消费者做判重

## 如何防止高并发情况下消费者内存溢出

> 设置prefetch count

---

## 几种MQ对比

|            | ActiveMQ         | RabbitMQ                                                     | RocketMQ                | Kafka         |
| ---------- | ---------------- | ------------------------------------------------------------ | ----------------------- | ------------- |
| 吞吐量     | 万级             | 万级                                                         | 10万级                  |               |
| 消息可靠性 | 较低概率会丢消息 |                                                              | 参数配置0丢失           | 参数配置0丢失 |
| 优缺点     | 社区活跃度较低   | 开源社区活跃、erlang开发性能好、有管理界面、集群扩展比较复杂 | topic可以很多性能影响小 |               |
| 可用性     |                  |                                                              |                         |               |
| 适用场景   | 小规模图吞吐     |                                                              |                         | 大数据        |



### 1、RabbitMQ

#### 普通集群模式

>主节点存放任务数据，访问子节点会从主节点获取数据

#### 镜像集群模式

>每个节点都放任务数据

### 2、kafka

> topic指定划分为n个partition，每个节点存一部分partition数据
>
> 单个节点分leader+follower主备两台机器，leader挂了，follower会被替换为leader继续提供读写

#### kafka如何做到高吞吐低延迟

> 1、先写入系统缓存，再由操作系统控制何时写磁盘
> 2、零拷贝

> 磁盘 - os cache - 应用程序cache - socket cache - 网卡
> 磁盘 - os cache - 网卡、仅copy一个描述符给socket


#### kafka写入数据不丢失

> 1、分布存储，partition
> 2、多副本冗余，选举leader提供读写、follower提供备份
> 3、ISR机制，每个分区都维护一个列表，记录leader和跟始终保持同步的follwer
> 写入时要求leader都写成功，同时至少一个ISR里的follwer也写入成功

#### kafka的acks参数对消息持久化的影响

> 0-只发送，是否成功接收写入不管
> 1-保证写入leader，但不保证follower同步（默认参数）
> all-需要follwer都同步完成

#### 是如何优化网络通信性能的

> 1、batch + request机制
> 同类topic的多条消息打包成一个batch
> 同一台机器的消息通过一个request请求发送多个batch

#### kafka是如何优化GC

> batch缓冲池机制，每次取一个batch，满了发送成功后放回，避免GC


## 读多写少

CopyOnWrite

> volatile修饰存储对象
> 使用重入锁，生成其副本对象进行写操作，不阻塞读操作，通过volatile即时同步变动

## 如果你设计一个消息中间件，该考虑哪写内容

> 1、分布式参考kafka每个topic分多个partition放在不同节点，每个节点做主备保证高可用
>
> 2、可扩展，增加机器时重新划分数据
>
> 3、消息要落盘，实现宕机可恢复
>
> 4、ack机制，保证数据的入队出队