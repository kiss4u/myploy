



# 杂乱

[TOC]

## 网络

### 网络模型

| OSI七层模型 | TCP/IP四层模型 | 功能                                     | TCP/IP协议                               |
| ----------- | -------------- | ---------------------------------------- | ---------------------------------------- |
| 应用层      | 应用层         | 数据传输、电子邮件、文件服务、虚拟重大UN | TFTP、HTTP、SNMP、FTP、SMTP、DNS、Telnet |
| 表示层      |                | 数据格式化、数据加密                     | 无                                       |
| 会话层      |                | 接触或建立联系                           | 无                                       |
| 传输层      | 传输层         | 提供端对端的接口                         | TCP、UDP                                 |
| 网络层      | 网络层         | 为数据包选择路由                         | IP、ICMP、RIP、OSPF、BGP、IGMP           |
| 数据链路层  | 链路层         | 传输有地址的帧及错误检测                 | SLIP、CSLIP/PPP、ARP、RARP、MTU          |
| 物理层      |                | 以二进制数据形式在物理媒体上传输数据     | IOS2110、IEEE802、IEEE802.2              |

### TCP和UDP传输协议 

| 比较值       | TCP                                    | UDP                                        |
| ------------ | -------------------------------------- | ------------------------------------------ |
| 是否连接     | 面向连接                               | 无                                         |
| 是否可靠     | 可靠                                   | 不可靠                                     |
| 连接对象个数 | 一对一                                 | 不限                                       |
| 传输方式     | 面向字节流                             | 面向报文                                   |
| 首部开销     | 最小20字节，最大60字节                 | 开销小，仅8字节                            |
| 适用场景     | 适用于要求可靠传输的应用，例如文件传输 | 适用于实时应用（IP电话、视频会议、直播等） |

### UDP

无需连接，加了报文头就开始传输，不关心对方是否收到，不支持数据包的分组、组合和排序，消息传输不可靠

### TCP

![img](%E6%9D%82%E4%B9%B1.assets/1344250-20190402112223228-10724396.png)



**ACK**：确认序号标志，0表示报文不含确认序号信息，1表示有效

**SYN**：建立连接请求标志，1表示请求连接

**FIN**：结束释放连接标志，1表示关闭本方数据流

**序号**（seq）：表示发送的数据字节流，确保TCP传输有序，对每个字节编号

**确认序号**（ack）：确认收到seq的数据流，为接收到的seq+ 1。只有ACK=1时才有效

#### 连接-三次握手(待整理)

![img](%E6%9D%82%E4%B9%B1.assets/20190516131245842.png)

##### **为什么必须是三次握手，不能用两次握手进行连接？**

1、防止旧的重复连接初始化造成混乱（主要原因）

```
客户端连续发送多次 SYN 建立连接的报文，在网络拥堵等情况下：

- 一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；
- 那么此时服务端就会回一个 SYN + ACK 报文给客户端；
- 客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 RST 报文给服务端，表示中止这一次连接。

如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：

- 如果是历史连接（序列号过期或超时），则第三次握手发送的报文是 RST 报文，以此中止历史连接；
- 如果不是历史连接，则第三次发送的报文是 ACK 报文，通信双方就会成功建立连接；
```

![img](%E6%9D%82%E4%B9%B1.assets/v2-ac0ecdad293a096d6b9402231af9f202_720w.jpg)

2、同步双方的初始序列号

```
TCP 协议的通信双方， 都必须维护一个「序列号（seq）」， 序列号是可靠传输的一个关键因素，它的作用：

- 接收方可以去除重复的数据；
- 接收方可以根据数据包的序列号按序接收；
- 可以标识发送出去的数据包中，哪些是已经被对方收到的；
```

![img](%E6%9D%82%E4%B9%B1.assets/v2-4c7d19df7e5964f1ee7a0a079ac30c51_720w.jpg)

3、避免资源浪费

#### 断开-四次挥手

> TCP是全双工（双向工作，互发信息）
>
> 每个方向都需要**一个 FIN 和一个 ACK**，因此通常被称为**四次挥手**。
>
> 这里一点需要注意是：**主动关闭连接的，才有 TIME_WAIT 状态。**



![img](%E6%9D%82%E4%B9%B1.assets/201905161747018.png)

*为什么客户端最后要等待2MSL？*

>1、客户端需要确认服务器已收到最后一次ACK，如服务器未收到可以发起请求重发，这样客户端还有时间重发，并重启2MSL倒计时
>
>2、使本次连接中产生的报文都有时间消失，不会在下一个连接中出现

### 流量控制

> 防止发送方发的太快，耗尽接收方的资源，从而使接收方来不及处理

#### 滑动窗口

> 用来告诉发送方当前可以发送的数据大小（或者说是接收端数据缓冲区大小）
>
> 接收端一旦发现自己的缓冲区快满了，就会将窗口大小设置成一个更小的值通知给发送端，发送端收到这个值后，就会减慢自己的发送速度；缓冲区满了，就会将窗口的大小设置为0，此时发送端将不再发送数据，但是需要定期发送一个窗口探测数据段，使接收端把窗口大小告诉发送端

### 拥塞控制

> 防止发送方发的太快，使得网络来不及处理，从而导致网络拥塞

#### TCP的四种拥塞控制算法

##### 慢开始

> 假设当前发送方拥塞窗口cwnd的值为1，而发送窗口swnd等于拥塞窗口cwnd，因此发送方当前只能发送一个数据报文段（拥塞窗口cwnd的值是几，就能发送几个数据报文段），接收方收到该数据报文段后，给发送方回复一个确认报文段，发送方收到该确认报文后，将拥塞窗口的值变为2，发送方此时可以连续发送两个数据报文段，接收方收到该数据报文段后，给发送方一次发回2个确认报文段，发送方收到这两个确认报文后，将拥塞窗口的值加2变为4，发送方此时可连续发送4个报文段，接收方收到4个报文段后，给发送方依次回复4个确认报文，发送方收到确认报文后，将拥塞窗口加4，置为8，发送方此时可以连续发送8个数据报文段，接收方收到该8个数据报文段后，给发送方一次发回8个确认报文段，发送方收到这8个确认报文后，将拥塞窗口的值加8变为16，
>

##### 拥塞避免

> 每个传输轮次，拥塞窗口cwnd只能线性加一，而不是像慢开始算法时，每个传输轮次，拥塞窗口cwnd按指数增长。同理，16+1……直至到达24，假设24个报文段在传输过程中丢失4个，接收方只收到20个报文段，给发送方依次回复20个确认报文段，一段时间后，丢失的4个报文段的重传计时器超时了，发送发判断可能出现拥塞，更改cwnd和ssthresh.并重新开始慢开始算法

##### 快重传

##### 快恢复



![img](https://img-blog.csdnimg.cn/20190731155254165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDMxNDA2,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20190731165743903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDMxNDA2,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20190731165605396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDMxNDA2,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20190731184314574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDMxNDA2,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20190731184935595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDMxNDA2,size_16,color_FFFFFF,t_70)

### 流量控制和拥塞控制的区别

|          | 丢包位置 | 作用对象                                                     |
| -------- | -------- | ------------------------------------------------------------ |
| 流量控制 | 接收端   | 控制的对象是接收方，怕发送方发的太快，使得接收方来不及处理   |
| 拥塞控制 | 路由器   | 控制的对象是网络，怕发送方发的太快，造成网络拥塞，使得网络来不及处理 |
|          |          |                                                              |



### cookie和session

http无状态协议，cookie和session分别用来在客户端和服务端存储一些用户信息

###

## restful

> post 参数放在request的head或body里，无大小限制
>
> get 参数拼接在url后，用?分隔，&连接；数据有大小限制
>
> put
>
> delete



## JVM

![img](%E6%9D%82%E4%B9%B1.assets/1190710-20180802114046965-1912546621.png)

| 分区       | 存储                              |                                        |
| ---------- | --------------------------------- | -------------------------------------- |
| 堆         | 对象实例                          |                                        |
| 栈         | 局部变量、对象引用                | 虚拟机（java）、本地（native JNI那些） |
| 程序计数器 |                                   |                                        |
| 方法区     | 静态变量+常量+类信息+运行时常量池 |                                        |

![img](%E6%9D%82%E4%B9%B1.assets/aHR0cDovL3AzLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzJmNjdmYzQzMWE5NzQ4ODk5OWNiNWNlMzQ4ZjNjMzA5)


|            |          |        |            |
| ---------- | -------- | ------ | ---------- |
| 新生代     | 存放变量 | YongGC |            |
| 老年代     | 存放对象 | FullGC |            |
| ~~永久代~~ |          |        | 上述方法区 |

对象如何进入老年代？
一般对象创建会被放到eden区，每次GC后年龄+1，当达到一个阈值时会被放到老年代。
-XX:MaxTenuringThreshold 设置，默认值为15
特殊：大对象在新生代无法装入时，会直接进入老年代，可以设置这个大小
-XX:PretenureSizeThreshold

### GC算法

| 算法      | 概述                                                         | 方式                                                         | 缺点                                  | 备注       |
| --------- | :----------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------- | ---------- |
| 标记-清除 | 从GC root进行遍历，把可达对象都标记，剩下那些不可达的进行清除 | 初始标记、并发标记、重新标记、清除                           | 1、效率问题 2、产生碎片，大对象触发GC | 适合老年代 |
| 标记-压缩 | 标记，无效对象向一侧移动，清除边界区域以外                   |                                                              |                                       | 适合老年代 |
| 复制      | 划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完，将还存活着的对象复制到另外一块，然后再把已使用过的内存空间一次清理掉 | 新生代Eden和survivor(from、to)来回转移，如果survivor空间不够直接进入老年代 |                                       | 适合新生代 |
| 分代      | 根据对象的特点把内存分为N块，而后根据每个内存的特点使用不同的算法 |                                                              |                                       |            |

### 调优

调整新生代和老年代大小，减少GC次数和频率

### 回收器

| 类型                |                         |                                                              |            |                              |                                                              |
| ------------------- | ----------------------- | ------------------------------------------------------------ | ---------- | ---------------------------- | ------------------------------------------------------------ |
| 串行回收器          | -XX:+UseSerialGC        | 单线程执行GC                                                 |            | 只适用于小数据量             | 单线程stop-the-world的方式进行收集。当内存不足时，串行GC设置停顿标识，待所有线程都进入安全点(Safepoint)时应用线程暂停，采用标记-整理 |
| 并行回收器          | -XX:+UseParallelGC      | 多个线程执行GC                                               | 吞吐量高   | 适用于科学技术和后台处理等   | 年轻代采用复制算法，老年代采用标记-整理                      |
| CMS回收器           | -XX:+UseConcMarkSweepGC | GC和应用程序一起执行（STW很短），回收时系统不会停止运行，保证系统的响应时间 | 响应要求高 | 适用于应用服务器、电信领域等 | 由于并发进行，CMS在收集与应用线程会同时会增加对堆内存的占用，也就是说，CMS必须要在老年代堆内存用尽之前完成垃圾回收，否则CMS回收失败时，将触发担保机制，串行老年代收集器将会以STW的方式进行一次GC，从而造成较大停顿时间；</br> 标记清除算法无法整理空间碎片，老年代空间会随着应用时长被逐步耗尽，最后将不得不通过担保机制对堆内存进行压缩。CMS也提供了参数-XX:CMSFullGCsBeForeCompaction(默认0，即每次都进行内存整理)来指定多少次CMS收集之后，进行一次压缩的Full GC。 |
| G1（Garbage First） | -XX:+UseG1GC            | 堆被划分成 许多个连续的区域                                  |            |                              | 支持多CPU和垃圾回收线程<br/>在主线程暂停的情况下，使用并行收集<br/>在主线程运行的情况下，使用并发收集 |

### 参数

|                                 | 说明                                          | 备注                                                         |
| ------------------------------- | --------------------------------------------- | ------------------------------------------------------------ |
| -Xms                            | 最小堆内存                                    | 默认内存1/64                                                 |
| -Xmx                            | 最大堆内存                                    | 默认内存1/4，一般xms和xmx设置成相同，避免垃圾回收后重新分配内存，出现缩容扩容 |
| -Xmn                            | 新生代大小                                    |                                                              |
| -XX:RestrictContended           | Contended注解启用（解决伪共享，填充整内存行） |                                                              |
| -XX:ContendedPaddingWidth       | 内存行字节填充宽度                            |                                                              |
| -XX:PreBlockSpinsh              | 自旋锁尝试次数                                |                                                              |
| -XX:NewRatio                    | 新生代老年代比例                              |                                                              |
| -XX:SurvivorRatio               | 新生代区比例                                  |                                                              |
| -XX:+UseSerialGC                | 设置串行收集器                                |                                                              |
| -XX:+UseParallelGC              | 设置并行收集器                                | 仅对年轻代有效                                               |
| -XX:+UseConcMarkSweepGC         | 设置并发收集器                                |                                                              |
| -XX:+ParallelGCThreads=20       | 并行收集器线程数                              |                                                              |
| -XX:+PrintGC                    | 输出GC信息                                    |                                                              |
| -XX:+HeapDumpOnOutOfMemoryError | 当应用抛出OutOfMemoryError时生成dump文件      |                                                              |
| -XX:HeapDumpPath                | dump文件路径                                  |                                                              |



### 对象是否存活

判断对象是否存活，是否需要回收

1. 虚拟机栈（栈帧中的本地变量表）中引用的对象。
2. 方法区中类静态属性引用的对象。
3. 方法区中常量引用的对象。

|        |                                                              |      |      |
| ------ | ------------------------------------------------------------ | ---- | ---- |
| 强引用 | Object obj = new Object()                                    |      |      |
| 软引用 | Referred strong = new Referred();        SoftReference<Referred> soft = new SoftReference<Referred>(strong);         SoftRef.collect(); |      |      |
| 弱引用 | Referred strong = new Referred();        WeakReference<Referred> weak = new WeakReference<>(strong);         WeakRef.collect(); |      |      |
| 虚引用 | PhantomReference                                             |      |      |

### Gc Roots

以GC Roots对象为起点向下搜索，其走过的路径（引用链），当一个对象到GC Roots没有任何引用链，则此对象不可用

> Class：系统类加载器加载的对象
>
> Thread：活着的线程
>
> Stack Local：栈中的对象（java方法本地变量或参数）
>
> JNI Local：JNI栈中的对象（ JNI方法的本地变量或参数）
>
> JNI Global：JNI栈中的全局对象（全局JNI引用）
>
> 正在被用于同步的各种锁对象
>
> JVM自身持有的对象，比如系统类加载器等





### 优化命令

| 命令   | 功能     |                                                            |                                               |
| ------ | -------- | ---------------------------------------------------------- | --------------------------------------------- |
| jstack | 查看线程 |                                                            |                                               |
| jmap   | 查看内存 | 得到运行java程序的内存分配的详细情况。例如实例个数，大小等 | jmap -dump:format=b,file=serviceDump.dat 6214 |
| jstat  | 性能分析 | 可以查看gc相关信息                                         |                                               |
| jfr    | 飞行记录 |                                                            |                                               |



### TLAB？线程私有内存？



## IO模型

### IO过程分两阶段

1. 准备阶段（从设备读取数据到内核空间的缓冲区）
2. 处理阶段（数据从内核空间复制回用户空间）

 ![img](%E6%9D%82%E4%B9%B1.assets/5350978-0f2eed658e1071ce.png)

### 模型种类

| 类型                            | 内核级别 |                                                              |                                                             |
| ------------------------------- | -------- | ------------------------------------------------------------ | ----------------------------------------------------------- |
| 同步阻塞IO（Blocking IO）       | 阻塞     | 客户端进程等待，直到完成                                     | 服务端优化线程模型，使用线程池实现伪异步                    |
| 同步非阻塞IO（Non-blocking IO） | 非阻塞   | 进程调用recvfrom操作，如果IO设备没有准备好，立即返回ERROR，进程不阻塞。用户可以再次发起系统调用(可以轮询)，如果内核已经准备好，就阻塞，然后复制数据到用户空间。<br/>第一阶段数据没有准备好，可以先忙别的，等会再来看看。检查数据是否准备好了的过程是非阻塞的。<br/>第二阶段是阻塞的，即内核空间和用户空间之间复制数据时阻塞的。<br/> | *此NIO非Java NIO，后者是Java 的New IO，使用了IO多路复用模型 |
| 多路复用IO（IO Multiplexing）   | 阻塞     | 向Selector注册（可以理解为Map<key,channel>），系统轮询key查看是否有数据准备好可处理的，发起调用recvfrom |                                                             |
| 信号驱动IO（Signal driven）     | 非阻塞   |                                                              |                                                             |
| 异步IO（Asynchronous IO）       | 非阻塞   | 处理完成后，内核给客户端进程发信号                           |                                                             |

**同步异步、阻塞非阻塞的定义，要看从哪个层次来看，操作系统级别还是应用层级别**

### 多路复用IO

#### 基本原理

客户端操作服务器时就会产生这三种文件描述符(简称fd)：writefds(写)、readfds(读)、和exceptfds(异常)。select会阻塞住监视3类文件描述符，等有数据、可读、可写、出异常 或超时、就会返回；返回后通过遍历fdset整个数组来找到就绪的描述符fd，然后进行对应的IO操作。

#### Selector处理机制

| 方法   | 方式      | 特点                                                         | 说明                                                         |                                                           |                                                  |
| ------ | --------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------------------------------------------------------- | ------------------------------------------------ |
| select | 轮询+遍历 | fd有限制，set（数组）存储，单进程1024（可修改）              |                                                              | 水平触发模式                                              |                                                  |
| poll   | 轮询+遍历 | fd无限制，用链表存储                                         |                                                              | 水平触发模式                                              |                                                  |
| epoll  | 轮询+回调 | fd无限制，用链表存储<br/>select/poll还要从内核空间复制消息到用户空间，而epoll通过内核空间和用户空间共享一块内存来减少复制 | 比如说有100W个连接，但是只有1W个活跃发起了IO请求，创建fd的时候生成callback，只轮询有callback请求的连接， | epoll()模型即支持水平触发，也支持边缘触发，默认是水平触发 | 根据平台类型自动设置，window无此机制，默认select |

Level_triggered(水平触发)：当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据一次性全部读写完(如读写缓冲区太小)，那么下次调用 epoll_wait()时，它还会通知你在上没读写完的文件描述符上继续读写，当然如果你一直不去读写，它会一直通知你！！！如果系统中有大量你不需要读写的就绪文件描述符，而它们每次都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率！！！

Edge_triggered(边缘触发)：当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你！！！这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符！！！

## Reactor模式


### 含义

Reactor（反应器模式），是一种处理一个或多个客户端并发交付服务请求的事件设计模式。当请求抵达后，服务处理程序使用I/O多路复用策略，然后同步地派发这些请求至相关的请求处理程序。
### 特点

同步非阻塞，使用I/O多路复用

### 类图

![img](%E6%9D%82%E4%B9%B1.assets/4235178-2d83a09abf0a3436.png)

### 角色构成



### 对应netty实现方式







## 常见的服务端线程模型

### **Thread per Connection**

NIO出现前，传统的java网络编程方案所采用的线程模型。即有一个主循环，socket.accept阻塞等待，当建立连接后，创建新的线程/从线程池中取一个，把该socket连接交由新线程全权处理。这种方案优缺点都很明显，优点即实现简单，缺点则是方案的伸缩性受到线程数的限制。

### **Reactor in Single Thread**

NIO出后，采用IO多路复用机制。我们抽取出一个单线程版的reactor模型，时序图见下文，该方案只有一个线程，所有的socket连接均注册在了该reactor上，由一个线程全权负责所有的任务。它实现简单，且不受线程数的限制。这种方案受限于使用场景，仅适合于IO密集的应用，不太适合CPU密集的应用，且适合于CPU资源紧张的应用上。

![Reactor Single Thread](%E6%9D%82%E4%B9%B1.assets/reactor-single-thread.png)

### **Reactor + Thread Pool**

方案2由于受限于使用场景，但为了可以更充分的使用CPU资源，抽取出一个逻辑处理线程池。reactor仅负责IO任务，线程池负责所有其它逻辑的处理。虽然该方案可以充分利用CPU资源，但是这个方案多了进出thread pool的两次上下文切换。

![Reactor + Thread Pool](%E6%9D%82%E4%B9%B1.assets/reactor-thread-pool.png)

### **Reactors in threads**

基于方案3缺点的考虑，将reactor分成两个部分。main reactor负责连接任务（accept、connect等），sub reactor负责IO、逻辑任务，即mina与netty的线程模型。该方案适应性十分强，可以调整sub reactor的数量适应CPU资源紧张的应用；同时CPU密集型任务时，又可以在业务处理逻辑中将任务交由线程池处理，如方案5。该方案有一个不太明显的缺点，即session没有分优先级，所有session平等对待均分到所有的线程中，这样可能会导致优先级低耗资源的session堵塞高优先级的session。

![Reactors in threads](%E6%9D%82%E4%B9%B1.assets/reactors-in-threads.png)

### **Reactors in threads + Threads pool**

上一种方案的优化，增加了应用线程池：调整reactor数量、调整thread pool大小等。

![Reactors in threads + Thread pool](%E6%9D%82%E4%B9%B1.assets/reactors-in-threads-thread-pool.png)

## 序列化协议

|          | 优点                                           | 缺点                   | 使用场景 |
| -------- | ---------------------------------------------- | ---------------------- | -------- |
| XML      | 可读性好                                       | 文件庞大               | 配置文件 |
| JSON     | 易与读写、扩展性好、序列化后数据小、解析速度快 | 数据的描述性比XML差    |          |
| Protobuf | 序列化反序列化速度快、体积更小                 | 需要依赖于工具生成代码 |          |



## RMI、RPC、WebService
解决分布式系统中，服务之间的调用问题

![img](%E6%9D%82%E4%B9%B1.assets/45366c44f775abfd0ac3b43bccc1abc3_720w.jpg)

| 名词                                        | 介绍                                              | 理解                                     |                           |
| ------------------------------------------- | ------------------------------------------------- | ---------------------------------------- | ------------------------- |
| RPC（remote procedure call）远程过程调用    | RPC不仅可以走HTTP/HTTPS，也可以自定义 tcp 协议    | 可以理解为一种功能，调用远程服务上的方法 |                           |
| RMI（remote method invocation）远程接口调用 |                                                   | 可以理解为是Java语言细化版的RPC实现      |                           |
| WebService                                  | 使用SOAP作为RPC报文，WSDL描述语言做为服务本身描述 | WebService是RPC的一套实现                | Apache Axis2、 Apache CXF |

*Mina、Netty网络应用程序框架都能实现RPC*

| 项目                                 | 通信协议 | 序列化协议               | 代码入侵                |                       |
| ------------------------------------ | -------- | ------------------------ | ----------------------- | --------------------- |
| thrift                               | TCP      | thrift                   | 基于thrift的IDL生成代码 |                       |
| dubbo（使用了hession）               | TCP      | 多协议支持，默认hessian  | 基于JAX-RS规范          | zookeeper充当服务发现 |
| hessian（轻量级remoting onhttp工具） | HTTP     | hessian（二进制RPC协议） |                         |                       |
| gRPC                                 | HTTP/2   | protobuf                 | 无代码入侵              |                       |
| SpringCloud - feign                  | HTTP     | JSON                     | 基于.Proto生成代码      |                       |



## 其他

### 模板引擎

Velocity、Freemarker、Beetl自动生成代码等

## 分布式锁

> redis、zookeeper对比

# 架构

### QPS/TPS

> TPS：每秒传输事务个数
>
> QPS：每秒查询数

并发数 = QPS*平均响应时间





1、 架构设计是否合理
2、 数据库设计是否合理
3、 代码是否存在性能方面的问题
4、 系统中是否有不合理的内存使用方式
5、 系统中是否存在不合理的线程同步方式
6、 系统中是否存在不合理的资源竞争